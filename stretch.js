// Generated by CoffeeScript 1.7.1
(function() {
  var Complex, Resampler, Stretcher, argv, fftw3, fs, getWindow, input, linearInterpolate, output, pcm, pitch, reader, resampler, stepSize, stream, stretcher, time, windowSize, writer,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  fftw3 = require('./build/Release/fftw3.node');

  stream = require('stream');

  pcm = require('./pcm');

  argv = require('optimist').usage('Usage: $0 input.wav output.wav [--time n] [--pitch n] [--step n] [--window n]').demand([2]).argv;

  fs = require('fs');

  Complex = require('./complex').Complex;

  getWindow = function(i, windowSize) {
    return Math.pow(1 - Math.pow((i - windowSize) / windowSize, 2), 1.25);
  };

  Stretcher = (function(_super) {
    __extends(Stretcher, _super);

    function Stretcher(stepBefore, windowSize, stepAfter) {
      this.stepBefore = stepBefore;
      this.windowSize = windowSize;
      this.stepAfter = stepAfter;
      stream.Transform.call(this, {
        objectMode: true
      });
      this.stretcherState = 'INIT';
      this.inputBuffer = [];
      this.outputBuffer = (function() {
        var _i, _ref, _results;
        _results = [];
        for (_i = 1, _ref = this.windowSize; 1 <= _ref ? _i <= _ref : _i >= _ref; 1 <= _ref ? _i++ : _i--) {
          _results.push(0);
        }
        return _results;
      }).call(this);
      this.forwardPlan = new fftw3.Plan(this.windowSize, true);
      this.backwardPlan = new fftw3.Plan(this.windowSize, false);
      this.timeSinceLastWindow = 0;
    }

    Stretcher.prototype._transform = function(number, encoding, done) {
      var checkAgain, el, fftBuffer, i, _i, _len, _ref;
      switch (this.stretcherState) {
        case 'INIT':
          this.inputBuffer.push(number);
          if (this.inputBuffer.length === this.windowSize) {
            this.stretcherState = 'TRANSFORMING';
          }
          return done();
        case 'TRANSFORMING':
          this.timeSinceLastWindow += 1;
          this.inputBuffer.shift();
          this.inputBuffer.push(number);
          if (this.timeSinceLastWindow === this.stepBefore) {
            fftBuffer = [];
            _ref = this.inputBuffer;
            for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
              el = _ref[i];
              fftBuffer.push(new Complex(el * getWindow(i, this.windowSize), 0));
            }
            this.forwardPlan.execute(Complex.flatten(fftBuffer), checkAgain = (function(_this) {
              return function(data) {
                var _j, _len1;
                data = Complex.inflate(data);
                for (i = _j = 0, _len1 = data.length; _j < _len1; i = ++_j) {
                  el = data[i];
                  data[i] = Complex.fromPolar(Math.random() * 2 * Math.PI, data[i].mag());
                }
                return _this.backwardPlan.execute(Complex.flatten(data), function(ifft) {
                  var _k, _l, _len2, _ref1;
                  ifft = Complex.inflate(ifft);
                  for (i = _k = 0, _len2 = ifft.length; _k < _len2; i = ++_k) {
                    el = ifft[i];
                    _this.outputBuffer[i] += el.x / _this.windowSize * getWindow(i, _this.windowSize);
                  }
                  for (_l = 1, _ref1 = _this.stepAfter; 1 <= _ref1 ? _l <= _ref1 : _l >= _ref1; 1 <= _ref1 ? _l++ : _l--) {
                    _this.push(_this.outputBuffer.shift() + Math.random() / 1000);
                    _this.outputBuffer.push(0);
                  }
                  return done();
                });
              };
            })(this));
            return this.timeSinceLastWindow = 0;
          } else {
            return done();
          }
      }
    };

    return Stretcher;

  })(stream.Transform);

  linearInterpolate = function(before, after, ratio) {
    return before * (1 - ratio) + after * ratio;
  };

  Resampler = (function(_super) {
    __extends(Resampler, _super);

    function Resampler(factor) {
      this.factor = factor;
      stream.Transform.call(this, {
        objectMode: true
      });
      this.position = 0;
      this.lastDataPoint = 0;
    }

    Resampler.prototype._transform = function(number, encoding, done) {
      var i, _i, _ref, _ref1;
      for (i = _i = _ref = Math.ceil(this.position), _ref1 = Math.ceil(this.position + this.factor); _ref <= _ref1 ? _i < _ref1 : _i > _ref1; i = _ref <= _ref1 ? ++_i : --_i) {
        this.push(linearInterpolate(this.lastDataPoint, number, (i - this.position) / this.factor) + Math.random() / 1000);
      }
      this.position += this.factor;
      this.lastDataPoint = number;
      return done();
    };

    return Resampler;

  })(stream.Transform);


  /*
  stretch = (input, output, stepBefore, windowSize, stepAfter) ->
    reader = new pcm.Reader(); input.pipe reader
    writer = new pcm.Writer(); writer.pipe output
    
    inputBuffer = []
  
    for i_ in [1..windowSize]
      until (bit = reader.read())?
        await setTimeout defer(), 0
      inputBuffer.push bit
    
    outputBuffer = (0 for [1..windowSize])
    
     * Create fftw plans
    forwardPlan = new fftw3.Plan windowSize, true
    backwardPlan = new fftw3.Plan windowSize, false
  
    while true
       * Apply the Hanning window
      fftBuffer = []
      for el, i in inputBuffer
        fftBuffer.push new Complex(el * getWindow(i, windowSize), 0)
  
       * Apply the fft transform
      await forwardPlan.execute Complex.flatten(fftBuffer), defer data
  
      data = Complex.inflate data
      
       * Randomize phases
      for el, i in data
        data[i] = Complex.fromPolar (Math.random() * 2 * Math.PI), data[i].mag()
  
       * Inverse-fft
      await backwardPlan.execute Complex.flatten(data), defer ifft
  
      ifft = Complex.inflate ifft
      
       * Overlap-add
      for el, i in ifft
        outputBuffer[i] += el.x / windowSize * getWindow i, windowSize
      
      shouldBreak = false
  
       * Advance the input buffer
      for i_ in [1..stepBefore]
        unless (bit = reader.read())? then shouldBreak = true; break
        inputBuffer.shift(); inputBuffer.push bit
  
      if shouldBreak then break
  
       * Advance output buffer
      for [1..stepAfter]
        writer.write outputBuffer.shift() + Math.random() / 1000
        outputBuffer.push 0
   */

  input = fs.createReadStream(argv._[0]);

  output = fs.createWriteStream(argv._[1]);

  reader = new pcm.Reader();

  input.pipe(reader);

  writer = new pcm.Writer();

  writer.pipe(output);

  windowSize = argv.window || argv.w || 700;

  stepSize = argv.step || argv.s || 100;

  time = argv.time || argv.t || 1;

  pitch = argv.pitch || argv.p || 1;

  stretcher = new Stretcher(stepSize, windowSize, stepSize * time / pitch);

  resampler = new Resampler(pitch);

  reader.pipe(stretcher).pipe(resampler).pipe(writer);

}).call(this);
