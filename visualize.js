// Generated by CoffeeScript 1.7.1
(function() {
  var Complex, fftw3, fs, pcm, stream, _;

  fftw3 = require('./build/Release/fftw3.node');

  fs = require('fs');

  stream = require('stream');

  pcm = require('./pcm');

  _ = require('underscore');

  Complex = require('./complex').Complex;

  google.load('visualization', '1');

  google.setOnLoadCallback(function() {
    var FRAMES, WINDOW, getPowerTable, input, reader;
    getPowerTable = function(options) {
      var buffer, plan, powerTable, powerTableIndex, timeSinceLastFrame;
      options = _.extend({
        windowSize: 8000,
        stepSize: 1000,
        nframes: 5,
        success: function() {}
      }, options);
      if (options.stream == null) {
        throw new Error('Missing "stream" option.');
      }
      powerTable = [];
      plan = new fftw3.Plan(options.windowSize, true);
      buffer = [];
      timeSinceLastFrame = 0;
      powerTableIndex = 0;
      return options.stream.on('data', function(number) {
        if (powerTableIndex < options.nframes) {
          buffer.push(number);
          if (buffer.length > options.windowSize) {
            buffer.shift();
          }
          timeSinceLastFrame += 1;
          if (timeSinceLastFrame >= options.stepSize && buffer.length === options.windowSize) {
            timeSinceLastFrame = 0;
            (function(powerTableIndex) {
              var checkAgain, el, fftBuffer;
              fftBuffer = (function() {
                var _i, _len, _results;
                _results = [];
                for (_i = 0, _len = buffer.length; _i < _len; _i++) {
                  el = buffer[_i];
                  _results.push(new Complex(el, 0));
                }
                return _results;
              })();
              return plan.execute(Complex.flatten(fftBuffer), checkAgain = function(data) {
                var i, powerSeries;
                data = Complex.inflate(data);
                powerSeries = (function() {
                  var _i, _len, _results;
                  _results = [];
                  for (i = _i = 0, _len = data.length; _i < _len; i = ++_i) {
                    el = data[i];
                    _results.push(el.mag());
                  }
                  return _results;
                })();
                powerTable[powerTableIndex] = powerSeries;
                if (powerTableIndex === options.nframes - 1) {
                  return options.success(powerTable);
                }
              });
            })(powerTableIndex);
            return powerTableIndex += 1;
          }
        }
      });
    };
    input = fs.createReadStream('audio.wav');
    reader = new pcm.Reader();
    input.pipe(reader);
    FRAMES = 10;
    WINDOW = 1000;
    return getPowerTable({
      stream: reader,
      nframes: FRAMES,
      windowSize: WINDOW,
      stepSize: WINDOW / 4,
      success: function(powers) {
        var data, frame, i, j, power, surfacePlot, _i, _j, _k, _len, _len1;
        data = new google.visualization.DataTable();
        for (i = _i = 1; 1 <= WINDOW ? _i <= WINDOW : _i >= WINDOW; i = 1 <= WINDOW ? ++_i : --_i) {
          data.addColumn('number', 'col' + i);
        }
        data.addRows(FRAMES);
        for (i = _j = 0, _len = powers.length; _j < _len; i = ++_j) {
          frame = powers[i];
          for (j = _k = 0, _len1 = frame.length; _k < _len1; j = ++_k) {
            power = frame[j];
            data.setValue(i, j, power / (WINDOW * 100));
          }
        }
        surfacePlot = new greg.ross.visualization.SurfacePlot(document.getElementById('surfacePlotDiv'));
        return surfacePlot.draw(data, {
          xPos: 50,
          yPos: 0,
          width: 500,
          height: 500,
          colourGradient: [
            {
              red: 0,
              green: 0,
              blue: 255
            }, {
              red: 0,
              green: 255,
              blue: 255
            }, {
              red: 0,
              green: 255,
              blue: 0
            }, {
              red: 255,
              green: 255,
              blue: 0
            }, {
              red: 255,
              green: 0,
              blue: 0
            }
          ],
          fillPolygons: true,
          xTitle: 'X',
          yTitle: 'Y',
          zTitle: 'Z',
          restrictXRotation: false
        });
      }
    });
  });

}).call(this);
